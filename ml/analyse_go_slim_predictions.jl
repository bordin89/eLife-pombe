#=
Predictions generated by PombeAgeingGenes.jl/scripts/ml/go_slim/prediction/*.jl
=#

using PombeAgeingGenes, JSON, .GeneOntology, OBOParse, DataFrames, Plots

plotlyjs()

function loaddata(dir::AbstractString, goterms::AbstractVector{<:AbstractString}=String[])
    df = DataFrame(id = String[], go = String[], y = Bool[], score = Float64[])

    if isempty(goterms)
        goterms = unique(map(x->split(x, ".")[1], readdir(dir)))
    end

    for goterm = goterms
        ŷs, ys, yids = try
            loaddata(dir, goterm)
        catch
            continue
        end

        goterm = replace(goterm, "GO"=>"GO:")

        for (ŷ, y, id) in zip(ŷs, ys, yids)
            push!(df, (id = id, go = goterm, y = y, score = ŷ))
        end
    end

    return df
end

function loaddata(dir::AbstractString, goterm::AbstractString)
    d = JSON.parsefile(joinpath(dir, goterm*".json"))
    ŷs = Array{Array{Float64}}(d["ŷs"])
    ys = Array{Array{Bool}}(d["ys"])
    yids = Array{Array{String}}(d["yids"])
    vcat(ŷs...), vcat(ys...), vcat(yids...)
end

# Known annotations
function get_annotations_and_ancestors(ontology, ecs=GeneOntology.EVIDENCE_CODES[:experimental])
    annotations = load(GOAnnotations, ecs=ecs)
    s = Set{Tuple{String,String}}()
    for x in annotations
        push!(s, (x.id, x.go))
        if haskey(ontology.terms, x.go)
            for a in ancestors(ontology, ontology[x.go])
                push!(s, (x.id, string(a)))
            end
        end
    end
    return s
end

go = load(GO)


# Load predictions

dir = joinpath(ENV["POMBEAGEINGGENES"], "Scripts", "ml", "go_slim", "RandomForestClassifier", "prediction", "b3dfb89", "ne_ff")

df = loaddata(dir)

all_predictions = size(df, 1)

unique(df.id)
unique(df.go)


# Precision recall curve

pr = PR(df.score, df.y)

plot(
    pr,
    c=:black,
    size=(450,300),
    left_margin=10Plots.PlotMeasures.mm,
)

savefig(joinpath(@__DIR__, "predict_GO_pr.pdf"))


# Remove known annotations with experimental or curated evidence codes
annotations_trusted = get_annotations_and_ancestors(
    go,
    EVIDENCE_CODES_TRUSTED,
)

filter!(r->(r.id, r.go) ∉ annotations_trusted, df)

new_predictions = size(df, 1)

existing_predictions = all_predictions - new_predictions


# Remove low probability predictions
filter!(r->r.score > 0.1, df)

good_predictions = size(df, 1)

low_probability_predictions = new_predictions - good_predictions

unique(df.id)
unique(df.go)
count(df.y) # How many of these predictions already have IEA evidence codes


# Annotations where previously only had bad evidence codes
annotations_untrusted = get_annotations_and_ancestors(
    go,
    [EVIDENCE_CODES[:automatic]; EVIDENCE_CODES[:bad]],
)

filter(r->(r.id, r.go) ∈ annotations_untrusted, df)


# Proteins that only had bad evidence codes before

ids_with_no_or_untrusted_annotations = setdiff(protein_coding_genes(), getindex.(annotations_trusted, 1))

@in(df, :id, ids_with_no_or_untrusted_annotations)


# Proteins that had experimental evidence codes before

annotations_experimental = get_annotations_and_ancestors(
    go,
    EVIDENCE_CODES[:experimental],
)

ids_annotations_experimental = Set(getindex.(annotations_experimental, 1))

tmp = filter(r->r.id ∈ ids_annotations_experimental, df)

count(tmp.y)


# Unknown function

fp = joinpath(ENV["POMBEAGEINGGENES"], "data", "pombe_genes_unknown_function.tsv")

unknown_function = Set(readlines(fp)[2:end])

tmp = @in(df, :id, unknown_function)

unique(tmp.id)
unique(tmp.go)
count(tmp.y) # How many of these predictions already have IEA evidence codes


# Priority unstudied

fp = joinpath(ENV["POMBEAGEINGGENES"], "data", "priority_unstudied_genes.tsv")

priority_unstudied_ids = Set(readlines(fp)[2:end])

tmp = @in(df, :id, priority_unstudied_ids)

unique(tmp.id)
unique(tmp.go)
count(tmp.y) # How many of these predictions already have IEA evidence codes


# EVIDENCE_CODES_TRUSTED


# Number of priority unstudied genes in STRING

# using CodecZlib
#
# fp = joinpath(ENV["POMBEAGEINGGENES"], "data/networks/4896.protein.links.v11.0.txt.gz")
#
# string_ids = Set{String}()
#
# open(GzipDecompressorStream, fp) do io
#     for line in eachline(io)
#         l = split(line)
#         push!(string_ids, l[1][6:end-2], l[2][6:end-2])
#     end
# end
#
# string_ids ∩ priority_unstudied_ids


# Genes in Bioneer

fp = joinpath(ENV["POMBEAGEINGGENES"], "data/Oct2019_BBSRC_results.csv.gz")

bioneer_ids = open(GzipDecompressorStream, fp) do io
    s = Set{String}()
    for line in eachline(io)
        l = split(line, ",")
        id = l[23]
        id == "wt" && continue
        id == "grid" && continue
        id == "empty" && continue
        push!(s, id)
    end
    s
end

priority_unstudied_ids ∩ bioneer_ids
tmp.id ∩ bioneer_ids
setdiff(tmp.id, bioneer_ids)



#=
function newpredictions(ŷs::AbstractVector, ys::AbstractVector, yids::AbstractVector)
    ys_pp = ys[ŷs .> .5]     # positively predicted ys
    yids_pp = yids[ŷs .> .5] # positively predicted yids
    yids_pp[.!ys_pp]         # positively predicted yids not in target set
end

# histogram(df[3], xlabel="Predicted probability", ylabel="Frequency", legend=false)
# savefig(joinpath(dir, "predicted_probabilities_hist.pdf"))
#
# wf = dropmissing!(unstack(df, 1, 2, 3))

# New predictions (i.e. FPs)

function find_new_predictions(ŷs, ys, yids, gos)
    new_predictions = []
    for i = 1:length(gos)
        preds = newpredictions(ŷs[i], ys[i], yids[i])
        if length(preds) > 0
            for p = preds
                push!(new_predictions, (identifier=p, goterm=gos[i]))
            end
        end
    end
    return new_predictions
end

new_predictions = find_new_predictions(ŷs, ys, yids, gos)



# How many terms would have been predicted by IEA?

using PombeAgeingGenes: GeneOntology
using PombeAgeingGenes.GeneOntology: EVIDENCE_CODES, EVIDENCE_CODES_TRUSTED, GO, GOAnnotations, Annotation

EVIDENCE_CODES_ALL = [EVIDENCE_CODES[:experimental];
                      EVIDENCE_CODES[:curated];
                      EVIDENCE_CODES[:automatic]]

# Account for predictions that are already in PomBase with IEA or `bad` evidence codes
ontology = load(GO)
annotations = Set(load(GOAnnotations, ecs=EVIDENCE_CODES_TRUSTED))
not_included_ecs = [EVIDENCE_CODES[:automatic]; EVIDENCE_CODES[:bad]]
not_included_annotations =
    unique!(load(GOAnnotations, ecs=not_included_ecs))

function account_for_predictions(new_predictions, ontology, not_included_annotations, not_included_ecs)
    res = []
    for p in new_predictions
        for d in [p.goterm; descendants(ontology, p.goterm)]
            for ec in not_included_ecs
                a = Annotation(p.identifier, d, ec)
                if a ∈ not_included_annotations
                    push!(res, (p, d, ec))
                end
            end
        end
    end
    return res
end

# I account for all 21 predictions that Maria found were already in PomBase
accounted_for = account_for_predictions(new_predictions, ontology, not_included_annotations, not_included_ecs)
unique(accounted_for)
unique(getindex.(accounted_for, 1))



# How many terms would have been predicted by FunFams?

df = CSV.read("Scripts/funfam/pombe_genes_conserved_in_vertebrates_funfam_goterm_prediction_strict.csv")
df = CSV.read("Scripts/funfam/pombe_genes_conserved_in_vertebrates_funfam_goterm_prediction_relaxed.csv")

funfam_predictions = Set(zip(df[:,:identifier], df[:,:goterm]))

function new_predictions_also_predicted_by_funfams(new_predictions::AbstractVector, ontology, funfam_predictions)
    predicted_by_funfams = []
    for p in new_predictions
        for d in [p.goterm; descendants(ontology, p.goterm)]
            pred = (p.identifier, d)
            if pred ∈ funfam_predictions
                push!(predicted_by_funfams, pred)
            end
        end
    end
    return predicted_by_funfams
end

new_predictions_also_predicted_by_funfams(new_predictions, ontology, funfam_predictions)

# function make_funfam_predictions(ids_goterms, ontology)
#     funfam_predictions = Tuple{String,String}[]
#     for (id, goterm) in ids_goterms
#         for ancestor in ancestors(ontology, ontology[goterm])
#             push!(funfam_predictions, (id, ancestor.id))
#         end
#     end
#     return Set(funfam_predictions)
# end
#
# funfam_predictions = make_funfam_predictions(zip(df[:,:identifier], df[:,:goterm]), ontology)
#
# function new_predictions_also_predicted_by_funfams(new_predictions, ontology, funfam_predictions)
#     predicted_by_funfams = []
#     for p in new_predictions
#         pred = (p.identifier, p.goterm)
#         if pred ∈ funfam_predictions
#             push!(predicted_by_funfams, pred)
#         end
#     end
#     return predicted_by_funfams
# end

# Are any ids that I made predictions for contained in the FunFam predictions?

funfam_predictions_ids = Set(getindex.(funfam_predictions, 1))
new_predictions_ids = Set(getindex.(new_predictions, 1))

funfam_predictions_ids ∩ new_predictions_ids



ps_df = DataFrame(ps)

CSV.write(joinpath(@__DIR__, "gene_goterm_predictions.csv"), ps_df)



# gene_list = CSV.read("/Users/harry/Downloads/gene_list.tsv")
#
# gene_list_set = Set(gene_list[:,1])
#
# Set(getindex.(ps, 2)) ∩ gene_list_set
#
# Set(getindex.(ps, 1))
# Set(getindex.(ps, 2))
#
# setdiff(getindex.(ps, 2), gene_list_set)
# setdiff(gene_list_set, getindex.(ps, 2))
#
# df = convert(DataFrame, load(FunFamHits))
#
# hits = load(FunFamHits)
# filter(x->x.id in gene_list_set, hits)


# Plot distribution of performance metrics
using StatsPlots

ps = Performance.(ŷs, ys)
plot(ps)
savefig(joinpath(dir, "performance_hist.pdf"))

# Confusion matrix
using PombeAgeingGenes: ConfusionMatrix

ConfusionMatrix(vcat(ŷs...), vcat(ys...))

# PR
using Plots

fig = plot()
for i = 1:length(ys)
    plot!(PR(ŷs[i], ys[i]), c=:black, α=.25, baseline=false, label="")
end
plot!(PR(vcat(ŷs...), vcat(ys...)), c=:black, lw=2)
savefig(joinpath(dir, "pr.pdf"))
=#
